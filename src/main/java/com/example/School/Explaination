
every request goes through this pipeline:
Http Request
   ↓
DelegatingFilterProxy
   ↓
FilterChainProxy
   ↓
[Security Filters][JWT filter -> filterSecurityInterceptor]
   ↓
Controller
=========================================================
Client (Login)
  ↓
AuthController (/api/auth/token)
  ↓
AuthenticationManager
  ↓
DaoAuthenticationProvider
  ↓
UserDetailsService → fetch user from DB
  ↓
PasswordEncoder → verify password
  ↓
✅ Authenticated → Generate JWT


The # ## AuthenticationManager in Spring Security is the core interface responsible for processing authentication requests.
Spring Security automatically creates an AuthenticationManager based on your configuration.
But, when you want to manually inject it (e.g., in your AuthController), you can’t @Autowired it directly — because it’s built inside the Spring Security filter chain.

That’s why you expose it using AuthenticationConfiguration:
Role of AuthenticationManager:
It receives authentication requests (like username and password).
It checks the credentials (using your UserDetailsService, password encoder, etc.).
If the credentials are valid, it returns an authenticated Authentication object.
If not, it throws an exception (like BadCredentialsException).
In your app:

The AuthenticationManager is used during login to authenticate users.
It is also used internally by Spring Security to check credentials for protected endpoints.
Summary:
AuthenticationManager is the main component that handles user authentication in your Spring Security setup.
It delegates the authentication to an AuthenticationProvider (usually a DaoAuthenticationProvider).
DaoAuthenticationProvider calls your UserDetailsService
    UserDetailsService.loadUserByUsername(username) is invoked.
    This loads the user from the database (via your UserRepository).

The DaoAuthenticationProvider checks the password:

passwordEncoder.matches(rawPassword, userDetails.getPassword())
If it matches → authentication succeeds.
If not → it throws BadCredentialsException

If successful:

You get an Authentication object containing user details.
You generate a JWT for this user.
Return that token in response.

The AuthenticationConfiguration config parameter in your authenticationManager bean method is provided by Spring Security. Its role is to give you access to the application's configured AuthenticationManager.

What does it do?

AuthenticationConfiguration is an auto-configured Spring Security bean.
It holds all the authentication setup (like your UserDetailsService, password encoder, etc.).
By calling config.getAuthenticationManager(), you get the fully configured AuthenticationManager that Spring Security will use for authenticating users.
In summary:
AuthenticationConfiguration config is a helper object that lets you obtain the main AuthenticationManager for your app, so you can inject and use it elsewhere (like in controllers or services). You do not need to configure it yourself—Spring Boot does it for you.

It knows how to build the AuthenticationManager based on:
    Your UserDetailsService bean
    Your PasswordEncoder
    Any authentication providers you configured

So when you call config.getAuthenticationManager(),
you’re telling Spring:
    “Give me the same AuthenticationManager that the security filter chain uses.”



#     **Why Do We Need AuthenticationConfiguration?**

Because in Spring Security 5.7+,
you no longer extend WebSecurityConfigurerAdapter.
That means Spring no longer gives you a built-in authenticationManager() method —
so you must define your own bean using AuthenticationConfiguration:

Summary Table
Concept                 	        Role	                                                                  When It’s Used
AuthenticationManager	        Verifies credentials (username/password)	                    Called in /api/auth/token
AuthenticationConfiguration	    Creates and provides the configured AuthenticationManager bean	During Spring context initialization
UserDetailsService	            Fetches user info from DB	                                    Called by AuthenticationManager
PasswordEncoder	                Compares raw & encoded passwords	                        Used inside DaoAuthenticationProvider


+-----------------------------------------------------------+
|                  Client / Postman / Frontend              |
|     POST /api/auth/token                                  |
|     { "username": "admin", "password": "admin123" }       |
+-----------------------------------------------------------+
                            │
                            ▼
+-----------------------------------------------------------+
|                  AuthController (your code)               |
|-----------------------------------------------------------|
| authenticationManager.authenticate(                       |
|     new UsernamePasswordAuthenticationToken(u, p) )       |
|                                                           |
| -> calls AuthenticationManager from AuthenticationConfig   |
+-----------------------------------------------------------+
                            │
                            ▼
+-----------------------------------------------------------+
|                AuthenticationManager                      |
|-----------------------------------------------------------|
| Delegates to AuthenticationProvider chain (like           |
| DaoAuthenticationProvider)                                |
+-----------------------------------------------------------+
                            │
                            ▼
+-----------------------------------------------------------+
|               DaoAuthenticationProvider                   |
|-----------------------------------------------------------|
| - Calls UserDetailsService.loadUserByUsername(username)   |
| - Gets UserDetails (with encoded password, roles)         |
| - Uses PasswordEncoder.matches(raw, encoded)              |
| - If success → returns Authenticated object               |
| - If fail → throws BadCredentialsException                |
+-----------------------------------------------------------+
                            │
                            ▼
+-----------------------------------------------------------+
|                UserDetailsService (your code)             |
|-----------------------------------------------------------|
| Loads user from DB (H2 in your case)                      |
| Returns UserDetailsImpl                                   |
+-----------------------------------------------------------+
                            │
                            ▼
+-----------------------------------------------------------+
|                PasswordEncoder (BCrypt)                   |
|-----------------------------------------------------------|
| Verifies raw password matches encoded password in DB      |
+-----------------------------------------------------------+
                            │
                            ▼
+-----------------------------------------------------------+
|              Authentication Successful!                   |
|-----------------------------------------------------------|
| AuthController generates JWT via JwtService               |
| Returns JSON response: { "token": "<jwt-token>" }         |
+-----------------------------------------------------------+


# What Happens Before This

When Spring Boot starts:

SecurityConfig is loaded.

It creates:

- UserDetailsService (to load users)
- PasswordEncoder (to hash/verify)
- AuthenticationManager (via AuthenticationConfiguration)

So when your controller calls authenticationManager.authenticate(...),Spring knows exactly how to authenticate that request.


# FilterSecurityInterceptor Enforces Access Rules

Before calling your controller, the FilterSecurityInterceptor checks your authorization rules — e.g.:

.authorizeHttpRequests()
    .requestMatchers("/api/user/**").hasRole("USER")
    .requestMatchers("/api/admin/**").hasRole("ADMIN")
    .anyRequest().authenticated()


It looks at:

The path (/api/user/profile)

The current user’s roles (from the Authentication object)

✅ If the user has permission → controller executes
❌ If not → AccessDeniedException → returns 403 Forbidden

## COMPLETE LIFECYCLE
Login Request (/api/auth/token)
    ↓
AuthenticationManager authenticates
    ↓
JwtService generates token
    ↓
Client stores token

Every Subsequent Request:
    ↓
JwtAuthenticationFilter intercepts
    ↓
JwtService validates token
    ↓
SecurityContext populated
    ↓
Controller executes
